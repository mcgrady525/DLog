<#
//*********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//    This code is licensed under the Microsoft Public License.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************
#>
<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#><#@ 
 output extension=".txt" encoding="utf-8" #><#

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataLoader loader = new MetadataLoader(this);
CodeRegion region = new CodeRegion(this, 1);
MetadataTools ef = new MetadataTools(this);

string inputFile = @"../../DLog.Data/DLogDB.edmx";
EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);
string namespaceName = code.VsNamespaceSuggestion();

EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);
WriteHeader(fileManager);

string txtOutput = string.Format("namespace {0}\r\n{{\r\n", code.EscapeNamespace(namespaceName));

foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
{
    fileManager.StartNewFile(entity.Name + "MetadataBase.cs");
    BeginNamespace(namespaceName, code);	
	
	var summary = (entity.Documentation == null ? string.Empty : entity.Documentation.Summary);	
	
	txtOutput += ("\r\n" + WriteTxtOutput(summary, code.Escape(entity)));
#>
/// <summary>
/// <#=summary#> CustomMetadata基類
/// </summary>
[DataContract]
public class <#=code.Escape(entity)#>MetadataBase
{
<#
	var primitiveProperties = entity.Properties.Where(p => p.TypeUsage.EdmType is PrimitiveType && p.DeclaringType == entity);
    if (primitiveProperties.Any())
    {
        foreach (EdmProperty edmProperty in primitiveProperties)
        {
            WriteProperty(code, edmProperty, ef.IsKey(edmProperty));
        }
    }
#>
}

<#
    EndNamespace(namespaceName);
}

fileManager.Process();

#>
<#= txtOutput #>}
<#+
void WriteHeader(EntityFrameworkTemplateFileManager fileManager)
{
    fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码是根据模板生成的。
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，则所做更改将丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using DataAnnotationsExtensions;//http://dataannotationsextensions.org/

<#+
    fileManager.EndBlock();
}

string WriteTxtOutput(string summary, string entityName)
{
	string str = string.Format("	#region {0} CustomMetadata\r\n\r\n", summary);
	str += "	/// <summary>\r\n";
    str += string.Format("	/// {0} CustomMetadata\r\n", summary);
    str += "	/// </summary>\r\n";
    str += "	[DataContract]\r\n";
    str += string.Format("	public class {0}Metadata : {0}MetadataBase\r\n", entityName);
    str += "	{\r\n";
	str += "\r\n";	
	str += "	}\r\n\r\n";
	str += "	#endregion\r\n\r\n";
	return str;
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}


void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}

void WriteProperty(CodeGenerationTools code, EdmProperty edmProperty, bool isKey)
{
    WriteProperty(Accessibility.ForProperty(edmProperty),
                  code.Escape(edmProperty.TypeUsage),
                  code.Escape(edmProperty),
                  code.SpaceAfter(Accessibility.ForGetter(edmProperty)),
                  code.SpaceAfter(Accessibility.ForSetter(edmProperty)),
				  edmProperty.Documentation == null ? string.Empty : edmProperty.Documentation.Summary,
				  edmProperty.Documentation == null ? string.Empty : edmProperty.Documentation.LongDescription,
				  edmProperty.Nullable,
				  ((edmProperty.TypeUsage.Facets.Any(p => p.Name == "MaxLength") && edmProperty.TypeUsage.Facets.First(p => p.Name == "MaxLength").Value != null) ? edmProperty.TypeUsage.Facets.First(p => p.Name == "MaxLength").Value.ToString() : string.Empty),
				  isKey
	);
}

static readonly char[] splitSigns = { ',', ':', '：', ' ', '(', '（',')','）','[',']','【','】', '=', '，', '.', '。', '\'', '"', '’', '‘', '“', '”', '~','!','@','#','$','%','^','&','*','-','_','+','=','{','}',';','?','/','\\','<','>','`','·','！','￥','…','|','—','；','、','？','》','《' };
void WriteProperty(string accessibility, string type, string name, string getterAccessibility, string setterAccessibility, string summary, string description, bool isNullable, string maxLength, bool isKey)
{	
#>

	/// <summary>
    /// <#=summary#>
	/// </summary>
    <#=string.IsNullOrWhiteSpace(summary) ? string.Empty : "[DisplayName(\"" + summary.Trim() + "\")]\r\n    " #><#= isKey ? "[Key]\r\n    " : string.Empty #><#= isNullable ? string.Empty : "[Required]\r\n    " #><#= string.IsNullOrEmpty(maxLength) || maxLength.ToUpper() == "MAX" ? string.Empty : "[StringLength(" + maxLength + ")]\r\n    " #><#=TypeAnnotation(type)#>[DataMember]
    <#=accessibility#> object <#=name#> { get; set; }
<#+
}

string TypeAnnotation(string type)
{
	if(type.StartsWith("Nullable<")) 
		type = type.Substring(9, type.Length - 9).TrimEnd('>');
	if(type.Contains('.')) type = type.Split('.')[1];
	string annotationType = string.Empty;
	switch(type.ToLower())
	{	
		case "datetime":
			annotationType = "[DataType(DataType.Date)]\r\n    [UIHint(\"DatePicker\")]\r\n    [DisplayFormat(DataFormatString = \"{0:yyyy/MM/dd}\", ApplyFormatInEditMode = true)]\r\n    ";
			break;
		case "uint":
		case "uint32":
			annotationType = "[Digits]\r\n    ";
			break;
		case "ushort":
		case "uint16":
			annotationType = "[Digits]\r\n    [Max(ushort.MaxValue)]\r\n    ";
			break;
		case "byte":
			annotationType = "[Digits]\r\n    [Max(byte.MaxValue)]\r\n    ";
			break;		
		//case "ulong":
		//case "uint64":
		case "int":
		case "int32":
			annotationType = "[Digits]\r\n    [Max(int.MaxValue)]\r\n    ";
			break;
		case "short":
		case "int16":
			annotationType = "[Digits]\r\n    [Range(short.MinValue, short.MaxValue)]\r\n    ";
			break;
		case "sbyte":
			annotationType = "[Digits]\r\n    [Range(sbyte.MinValue, sbyte.MaxValue)]\r\n    ";
			break;		
		case "long":
		case "int64":
			annotationType = "[Digits]\r\n    [Max(long.MaxValue)]\r\n    ";
			break;
		case "float":
			annotationType = "[Numeric]\r\n    [Range(float.MinValue, float.MaxValue)]\r\n    ";
			break;
		case "decimal":
		case "double":
			annotationType = "[Numeric]\r\n    ";
			break;
	}

	return annotationType;
}

#>